[
  {
    "path": "posts/2022-07-10-minimum-cost-network-flow-problem-in-r/",
    "title": "Minimum Cost Network Flow Problem in R",
    "description": "In this post we will walk through how to make least cost maximum flow decisions using R.",
    "author": [
      {
        "name": "Blake Conrad",
        "url": "https://github.com/conradbm"
      }
    ],
    "date": "2022-07-10",
    "categories": [],
    "contents": "\r\n\r\nContents\r\nTraffic Minimum Cost\r\nNetwork Flow\r\nThe Problem\r\nThe Data\r\nNetwork Visualization\r\n\r\nModel Data\r\nAverage In-Flow\r\nDemand\r\n\r\n\r\nLinear Programming (LP)\r\nLP Structure\r\nArc Constraints\r\nPutting It All Together\r\n\r\nSolve the LP\r\nVisualize Solution\r\nCleaning Up The Visual\r\nFlow vs. Capacity\r\nvs. Time\r\nShortest Path\r\nShortest Path\r\nVisualization\r\n\r\n\r\n\r\nTraffic Minimum Cost Network\r\nFlow\r\nOne common extension to Maximum Flow problems is to do\r\nit as cheaply as possible. In this article we will extend the maximum\r\nflow example we wrote on in the last\r\npost and include a minimum cost component. The generic problem\r\nformation is below:\r\nObjective \\[\r\nMinimize. \\sum_{(i,j)\\in A}{c_{ij}x_{ij}}   \r\n\\] \\[\r\ns.t.\r\n\\] Node Flow Constraints \\[\r\n\\sum_{j}{x_{ij}} - \\sum_{i}{x_{ji}} = b_i \\: \\forall i \\in N\r\n\\] Arc Flow Constraints \\[\r\nl_{ij} \\le x_{ij} \\le u_{ij} \\: \\forall (i,j) \\in A\r\n\\]\r\nThe Problem\r\nRoad networks are everywhere in our society. In any given\r\nintersection there is a flow of cars, intersections with stop lights,\r\nand connections between each. Every road has a feasible limit it can\r\nsupport. In fact, this is often the cause of most congestion. Our goal\r\nis to minimize the total time required for all cars to travel from node\r\n1 to node 6 in a fictitious road network.\r\nThe Data\r\n\r\n\r\nnodes <- data.frame(id = c(1:6), color = c(\"green\", rep(\"grey\", 4), \"red\"))\r\nedges <- data.frame(from = c(1, 1, 2, 2, 5, 4, 4, 3, 3), \r\n                    to = c(2, 3, 5, 4, 6, 5, 6, 5, 4),\r\n                    lower_bound = 0,\r\n                    upper_bound = c(800, 600, 100, 600, 600, 600, 400, 400, 300),\r\n                    time = c(10, 50, 70, 30, 30, 30, 60, 60, 10), # in minutes\r\n                    flow = 0, #TBD\r\n                    color = \"grey\") %>% dplyr::arrange(from, to)\r\nnodes\r\n\r\n  id color\r\n1  1 green\r\n2  2  grey\r\n3  3  grey\r\n4  4  grey\r\n5  5  grey\r\n6  6   red\r\n\r\nedges\r\n\r\n  from to lower_bound upper_bound time flow color\r\n1    1  2           0         800   10    0  grey\r\n2    1  3           0         600   50    0  grey\r\n3    2  4           0         600   30    0  grey\r\n4    2  5           0         100   70    0  grey\r\n5    3  4           0         300   10    0  grey\r\n6    3  5           0         400   60    0  grey\r\n7    4  5           0         600   30    0  grey\r\n8    4  6           0         400   60    0  grey\r\n9    5  6           0         600   30    0  grey\r\n\r\nNetwork Visualization\r\nWe can see the upper bounds plotted on the edges of this\r\ntransportation network below. The width indicates more capacity for\r\nflow. Examine the trade-off between time and space for travel between\r\narc (1,2).\r\n\r\n\r\ng <- igraph::graph_from_data_frame(d = edges,\r\n                                   directed = TRUE,\r\n                                   vertices = nodes)\r\n\r\n# Capacity plot\r\nplot(g, \r\n     main = \"Vehicle Transportion Network Capacities\", \r\n     edge.label = E(g)$upper_bound, \r\n     edge.width = E(g)$upper_bound/150,\r\n     vertex.color = V(g)$color,\r\n     edge.color = E(g)$color)\r\n\r\n\r\n# Time plot\r\nplot(g, \r\n     main = \"Vehicle Transportion Network Travel Time\", \r\n     edge.label = E(g)$time, \r\n     edge.width = E(g)$time/10,\r\n     vertex.color = V(g)$color,\r\n     edge.color = E(g)$color)\r\n\r\n\r\n\r\nModel Data\r\nAverage In-Flow\r\nFirst we assume the average number of cars that flow through this\r\nnetwork. This is often recovered from past databases that record the\r\nflows through the network.\r\n\r\n\r\nAVERAGE_FLOW <- 900 # per hour\r\nAVERAGE_FLOW\r\n\r\n[1] 900\r\n\r\nDemand\r\nNext we set up the demand that will be flowing through the network.\r\nThis is indicated as the vector b in our model formation\r\nabove. This means the initial node has a supply of 900 vehicles, while\r\nthe final node has a demand of 900 nodes. The objective is to flow as\r\nmany vehicles through the network, in the shortest amount of time.\r\n\r\n\r\ndemand <- c(AVERAGE_FLOW, rep(0, nrow(nodes)-2), -AVERAGE_FLOW)\r\ndemand\r\n\r\n[1]  900    0    0    0    0 -900\r\n\r\nLinear Programming (LP)\r\nLP Structure\r\nThe next step is to set up the optimization. Let’s do that now. There\r\nare 3 key ingredients.\r\nObjective\r\nConstraints\r\nDirections\r\nArc Constraints\r\nWe want to build the constraint matrix, which has 2 parts.\r\nArc Capacity Constraints\r\nNode Flow Constraints\r\nThe Arc Capacity Constraints are the first we\r\naddress.\r\nThe Amat, or A matrix, is the arc matrix which contains\r\nthe upper bounds. Since linear programming relies on the resource\r\nmatrix, we need one row for each arc, our dimensions for variable flow\r\nselection are the number of arcs also. So this means we need an\r\nidentity matrix for the rows of arcs and columns of\r\narcs.\r\n\r\n\r\ncreate_upper_arc_constraints <- function(edges){\r\n  Amat <- matrix(0, nrow = nrow(edges), ncol = nrow(edges))\r\n  Amat_dir <- rep(\"<=\", nrow(Amat))\r\n  Amat_rhs <- c()\r\n\r\n  for(i in 1:ncol(Amat)){\r\n    Amat[i,i] <- 1\r\n    Amat_rhs <- c(Amat_rhs, edges$upper_bound[i])\r\n  }\r\n  \r\n  list(Amat_upper = Amat,\r\n       Amat_upper_dir = Amat_dir,\r\n       Amat_upper_rhs = Amat_rhs)\r\n}\r\n\r\n# This could be higher than zero, but for standard LP this is the default configuration, so not needed.\r\n# create_lower_arc_constraints <- function(edges){\r\n#   Amat <- matrix(0, nrow = nrow(edges), ncol = nrow(edges))\r\n#   Amat_dir <- rep(\">=\", nrow(Amat))\r\n#   Amat_rhs <- c()\r\n# \r\n#   for(i in 1:ncol(Amat)){\r\n#     Amat[i,i] <- 1\r\n#     Amat_rhs <- c(Amat_rhs, edges$lower_bound[i])\r\n#   }\r\n#   \r\n#   list(Amat_lower = Amat,\r\n#        Amat_lower_dir = Amat_dir,\r\n#        Amat_lower_rhs = Amat_rhs)\r\n# }\r\n\r\nupper_results <- create_upper_arc_constraints(edges)\r\n# lower_results <- create_lower_arc_constraints(edges)\r\n# \r\n# Amat <- rbind(upper_results$Amat_upper, lower_results$Amat_lower)\r\n# Amat_dir <- c(upper_results$Amat_upper_dir, lower_results$Amat_lower_dir)\r\n# Amat_rhs <- c(upper_results$Amat_upper_rhs, lower_results$Amat_lower_rhs)\r\n\r\nAmat <- upper_results$Amat_upper\r\nAmat_dir <- upper_results$Amat_upper_dir\r\nAmat_rhs <- upper_results$Amat_upper_rhs\r\n\r\nAmat\r\n\r\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\r\n [1,]    1    0    0    0    0    0    0    0    0\r\n [2,]    0    1    0    0    0    0    0    0    0\r\n [3,]    0    0    1    0    0    0    0    0    0\r\n [4,]    0    0    0    1    0    0    0    0    0\r\n [5,]    0    0    0    0    1    0    0    0    0\r\n [6,]    0    0    0    0    0    1    0    0    0\r\n [7,]    0    0    0    0    0    0    1    0    0\r\n [8,]    0    0    0    0    0    0    0    1    0\r\n [9,]    0    0    0    0    0    0    0    0    1\r\n\r\nAmat_dir\r\n\r\n[1] \"<=\" \"<=\" \"<=\" \"<=\" \"<=\" \"<=\" \"<=\" \"<=\" \"<=\"\r\n\r\nAmat_rhs\r\n\r\n[1] 800 600 600 100 300 400 600 400 600\r\n\r\nThe Node Flow Constraints are the next to take care\r\nof.\r\nThe Bmat, or B matrix, is a matrix which contains the\r\nnode balance equations codified by flows.\r\nFor each node, we need to match it’s from node and\r\nto node with the appropriate inflow and outflow. If it\r\nmatches an inflow arc, this is increase, so 1\r\nis in the arc column. If it matches an outflow arch, this\r\nis decrease, so -1 is in the arc column. Otherwise\r\n0 remains as the placeholder. The sign here is\r\n== because they must match (i.e., supply = demand). If we\r\nrequire excess at certain points we can set this demand to be higher\r\nthan zero, but we will not do that here.\r\n\r\n\r\ncreate_node_constraints <- function(nodes, edges){\r\n    Bmat <- matrix(0, nrow = nrow(nodes), ncol = nrow(edges))\r\n    Bmat_dir <- rep(\"==\", nrow(Bmat))\r\n    Bmat_rhs <- rep(0, nrow(Bmat))\r\n    \r\n    for(i in 1:nrow(Bmat)){\r\n      node_id <- nodes[i, \"id\"]\r\n      for(j in 1:ncol(Bmat)){\r\n        edge_from <- edges[j,\"from\"]\r\n        edge_to <- edges[j, \"to\"]\r\n        \r\n        if(node_id == edge_from){\r\n          # print(paste(\"Outbound for \", node_id, \"From: \",edge_from, \"to: \", edge_to))\r\n          Bmat[i,j] = 1\r\n        }\r\n        else if(node_id == edge_to){\r\n          # print(paste(\"Inbound for \", node_id, \"From: \",edge_from, \"to: \", edge_to))\r\n          Bmat[i,j] = -1\r\n        }\r\n        else{\r\n          Bmat[i,j] = 0\r\n        }\r\n      }\r\n      Bmat_rhs[i] <- demand[i]\r\n    }\r\n    \r\n    list(Bmat = Bmat,\r\n         Bmat_dir = Bmat_dir,\r\n         Bmat_rhs = Bmat_rhs\r\n    )\r\n}\r\n\r\nresults <- create_node_constraints(nodes, edges)\r\nBmat <- results$Bmat\r\nBmat_dir <- results$Bmat_dir\r\nBmat_rhs <- results$Bmat_rhs\r\n\r\nBmat\r\n\r\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\r\n[1,]    1    1    0    0    0    0    0    0    0\r\n[2,]   -1    0    1    1    0    0    0    0    0\r\n[3,]    0   -1    0    0    1    1    0    0    0\r\n[4,]    0    0   -1    0   -1    0    1    1    0\r\n[5,]    0    0    0   -1    0   -1   -1    0    1\r\n[6,]    0    0    0    0    0    0    0   -1   -1\r\n\r\nBmat_dir\r\n\r\n[1] \"==\" \"==\" \"==\" \"==\" \"==\" \"==\"\r\n\r\nBmat_rhs\r\n\r\n[1]  900    0    0    0    0 -900\r\n\r\nPutting It All Together\r\nNext, the objective is going to be the time. This is the cost we have\r\nto pay for assigning flow to an arc. Let’s take a look at everything all\r\ntogether.\r\n\r\n\r\nf.obj <- edges %>% dplyr::pull(time)\r\nf.cons <- rbind(Amat, Bmat)\r\nf.rhs <- c(Amat_rhs, Bmat_rhs)\r\nf.dir <- c(Amat_dir, Bmat_dir)\r\n\r\nf.obj\r\n\r\n[1] 10 50 30 70 10 60 30 60 30\r\n\r\nf.cons\r\n\r\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\r\n [1,]    1    0    0    0    0    0    0    0    0\r\n [2,]    0    1    0    0    0    0    0    0    0\r\n [3,]    0    0    1    0    0    0    0    0    0\r\n [4,]    0    0    0    1    0    0    0    0    0\r\n [5,]    0    0    0    0    1    0    0    0    0\r\n [6,]    0    0    0    0    0    1    0    0    0\r\n [7,]    0    0    0    0    0    0    1    0    0\r\n [8,]    0    0    0    0    0    0    0    1    0\r\n [9,]    0    0    0    0    0    0    0    0    1\r\n[10,]    1    1    0    0    0    0    0    0    0\r\n[11,]   -1    0    1    1    0    0    0    0    0\r\n[12,]    0   -1    0    0    1    1    0    0    0\r\n[13,]    0    0   -1    0   -1    0    1    1    0\r\n[14,]    0    0    0   -1    0   -1   -1    0    1\r\n[15,]    0    0    0    0    0    0    0   -1   -1\r\n\r\nf.rhs\r\n\r\n [1]  800  600  600  100  300  400  600  400  600  900    0    0    0\r\n[14]    0 -900\r\n\r\nf.dir\r\n\r\n [1] \"<=\" \"<=\" \"<=\" \"<=\" \"<=\" \"<=\" \"<=\" \"<=\" \"<=\" \"==\" \"==\" \"==\" \"==\"\r\n[14] \"==\" \"==\"\r\n\r\nSolve the LP\r\nNow we unite everything together and drop it into the solver.\r\nRemember, we are trying to minimize cost in our objective, the\r\nconstraints will maximize the flow. So specify min.\r\n\r\n\r\nresults <- lp(direction = \"min\",  \r\n              objective.in = f.obj, \r\n              const.mat = f.cons, \r\n              const.dir = f.dir, \r\n              const.rhs = f.rhs)\r\n\r\nedges$flow <- results$solution\r\nedges\r\n\r\n  from to lower_bound upper_bound time flow color\r\n1    1  2           0         800   10  700  grey\r\n2    1  3           0         600   50  200  grey\r\n3    2  4           0         600   30  600  grey\r\n4    2  5           0         100   70  100  grey\r\n5    3  4           0         300   10  200  grey\r\n6    3  5           0         400   60    0  grey\r\n7    4  5           0         600   30  500  grey\r\n8    4  6           0         400   60  300  grey\r\n9    5  6           0         600   30  600  grey\r\n\r\nVisualize Solution\r\nNow that we have our flow we can do some visualizing and analysis.\r\nThere are two key graphics to examine; the\r\nflow vs. capacity and the flow vs. time.\r\nFirst, the flow vs. capacity will give us insights into\r\nstress on the network. This is because of their implicit advantage they\r\nsupply to the optimizer, maximum flows, so naturally, these get flooded\r\nwith traffic. Second, the flow vs. time will give us\r\ninsights into shortest distance paths (i.e., assuming time is\r\nproportional to distance, which is not always the case). This is because\r\npaths with shorter times will enable more to flow through in any given\r\ntime delta. Between these two visuals, a good assessment of the model\r\noutput is feasible.\r\n\r\n\r\n# Set the flow\r\nedges$flow <- results$solution\r\n\r\n# If the arc is flowing oil, change to black\r\nedges$color[which(edges$flow > 0)] <- \"black\"\r\n\r\n# If the arc is at capacity change it to red\r\nedges$color[which(edges$flow == edges$upper_bound)] <- \"red\"\r\n\r\ng <- igraph::graph_from_data_frame(d = edges,\r\n                                   directed = TRUE,\r\n                                   vertices = nodes)\r\n\r\n# Plot the flow and capacity\r\nplot(g,\r\n     edge.label = paste(\"(\",E(g)$flow, \r\n                        \",\",\r\n                         E(g)$upper_bound, \r\n                         \")\", \r\n                        sep=\"\"), \r\n     main = \"Traffic Flow | (flow, capacity)\", \r\n     vertex.color = V(g)$color,\r\n     vertex.size = 25,\r\n     vertex.label.cex = 1.6,\r\n     edge.color = E(g)$color,\r\n     edge.width = E(g)$flow/200)\r\n\r\n\r\n# Plot the time\r\nplot(g,\r\n     edge.label = paste(\"(\",E(g)$flow, \r\n                        \",\",\r\n                         E(g)$time, \r\n                         \")\", \r\n                        sep=\"\"), \r\n     main = \"Traffic Flow | (flow, time)\", \r\n     vertex.color = V(g)$color,\r\n     vertex.size = 25,\r\n     vertex.label.cex = 1.6,\r\n     edge.color = E(g)$color,\r\n     edge.width = E(g)$flow/200)\r\n\r\n\r\n\r\nCleaning Up The Visual\r\n\r\n\r\nnodes\r\n\r\n  id color\r\n1  1 green\r\n2  2  grey\r\n3  3  grey\r\n4  4  grey\r\n5  5  grey\r\n6  6   red\r\n\r\nvisNet_nodes <- nodes %>% \r\n                dplyr::mutate(label = paste(\"Location \", id),\r\n                              font.size =10,\r\n                              type = \"black\",\r\n                              shape = \"circle\",\r\n                              font = 12)\r\n\r\nvisNet_edges <- edges %>% \r\n                dplyr::mutate(label = paste(\"(\",flow,\",\",upper_bound,\")\",sep=\"\"),\r\n                              length = 250,\r\n                              width = flow/100,\r\n                              arrows = \"to\") \r\n  \r\nvisNetwork(visNet_nodes, \r\n           visNet_edges,\r\n           width = \"100%\",\r\n           main = \"Least Time Maximum Vehicle Flow | (flow, capacity)\")\r\n\r\n\r\n\r\nFlow vs. Capacity vs. Time\r\nTwo of the most popular roadways are\r\n2 -> 4 and 5 -> 6. These supply the\r\nleast amount of time and the most amount of capacity. Without a doubt,\r\nthe model has exploited these as much as possible. The only trick is,\r\njust how the flow gets there. We see up front that 1 ships\r\noff a 200 to 700 flow split from the 900\r\nsupply with the heavier allocation toward 2. Why?\r\n2 is connected to a popular\r\nroadway, meaning much more potential to flow (and\r\nquickly).\r\nIn order to get to 4, going through 3\r\nwill cost much more time (60 oppose to 40).\r\n3 has two outlets, but one is one of the worst\r\nroutes on the network due to it’s 60 minute trek, so it doesn’t even get\r\nany flow allocated.\r\nShortest Path\r\nThe shortest path shows one very interesting insight to this model;\r\nsending a maximum flow through the network is not all about time. The\r\nshortest path (least time) is the sequence\r\n1 -> 2 -> 4 -> 6. However, from the above, we see\r\nthat this isn’t the most stressed path. Why? We aren’t only\r\ninterested in short times for the vehicles flowing through the network.\r\nWe are also interested in getting them all through it! We assumed there\r\nwas a 900 average vehicle flow, and having a macro-level view of this\r\nsystem, sending them all down the shortest path would not solve it (that\r\nis, we would not send as much as possible, only as cheaply as possible;\r\nwe could have pushed more). In order to get the most cars sent through\r\nthe network, in the shortest amount of time we also must take advantage\r\nof the popular roadways that the model is straining (or\r\nadd incentive to the not so popular roadways with\r\ngreater capacity or shorter commute times).\r\n\r\n\r\nshortest.paths <- igraph::shortest_paths(graph = g, from = 1, to = 6)\r\ns_path <- shortest.paths$vpath[[1]]\r\ns_path\r\n\r\n+ 4/6 vertices, named, from a870128:\r\n[1] 1 2 4 6\r\n\r\nshortest_commute_time <- E(g, path = s_path)$time %>% sum\r\nshortest_commute_time\r\n\r\n[1] 100\r\n\r\nShortest Path Visualization\r\n\r\n\r\nE(g)$color <- \"black\"\r\nE(g, path = s_path)$color <- \"blue\"\r\n\r\nplot(g,\r\n     edge.label = paste(\"(\",E(g)$flow, \r\n                        \",\",\r\n                         E(g)$time, \r\n                         \")\", \r\n                        sep=\"\"), \r\n     main = \"Shortest Path | (flow, capacity)\", \r\n     vertex.color = V(g)$color,\r\n     vertex.size = 25,\r\n     vertex.label.cex = 1.6,\r\n     edge.color = E(g)$color,\r\n     edge.width = E(g)$flow/200)\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-07-10-minimum-cost-network-flow-problem-in-r/minimum-cost-network-flow-problem-in-r_files/figure-html5/visual_1-1.png",
    "last_modified": "2022-07-10T20:09:00-04:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-07-09-maximum-network-flows-in-r/",
    "title": "Maximum Network Flows in R",
    "description": "In this post we will walk through how to make a maximum flow decision using network flows and linear programming.",
    "author": [
      {
        "name": "Blake Conrad",
        "url": "https://github.com/conradbm"
      }
    ],
    "date": "2022-07-09",
    "categories": [],
    "contents": "\r\n\r\nContents\r\nOil Flow Maximization\r\nProblem Formation\r\nNetwork Structure\r\nNetwork Visual\r\nBig M\r\n\r\nLinear Programming (LP)\r\nLP Structure\r\nConstraints\r\nObjective\r\n\r\nSolve the LP\r\nVisualize Maximum Flow\r\nSolution\r\nCleaning Up The Visual\r\n\r\n\r\nReferences\r\n\r\nOil Flow Maximization\r\nOne classic problem in Network Flows and\r\nOptimization is called the Max-Flow Problem.\r\nThis takes any two nodes in a network, s and t\r\nand attempts to send as much of a resource (or multiple) from\r\ns to t. This is called a flow,\r\nand the flow which maximizes the total bandwidth of the network is\r\ncalled the maximum flow.\r\nFirst, the problem starts with an objective: to\r\nmaximize flow. These are denoted as,\r\n\\[x_{ij} = flow \\: on \\: node_i \\: to \\:\r\nnode_j \\:(or \\: on \\: arc \\: (i,j))\\]\r\nSecond, the problem has a set of constraints, these are called the\r\narc capacities. These are denoted as,\r\n\\[u_{ij} = maximum \\:amount \\:of \\:\r\nfeasible \\: flow \\: on \\: node_i \\: to \\: node_j \\:(or \\: on \\: arc \\:\r\n(i,j))\\] Last, the network graph is supplied as a set of\r\nconnections under the traditional network structure:\r\n\\[ G = (N,E) \\]\r\nProblem Formation\r\nFor our problem, the feasible flow is going to be in units of\r\nmillions of barrels of oil per hour that will pass through an arc of\r\npipeline.\r\nNetwork Structure\r\nThe source for our network is indicated in green and sink in red.\r\n\r\n\r\nnodes <- data.frame(id = c(0:4), color = c(\"green\", rep(\"grey\", 3), \"red\"))\r\nedges <- data.frame(from = c(0,0,1,1,3,2), to = c(1,2,2,3,4,4), capacity = c(2,3,3,4,1,2), color = \"grey\")\r\n\r\nedges\r\n\r\n  from to capacity color\r\n1    0  1        2  grey\r\n2    0  2        3  grey\r\n3    1  2        3  grey\r\n4    1  3        4  grey\r\n5    3  4        1  grey\r\n6    2  4        2  grey\r\n\r\nNetwork Visual\r\n\r\n\r\ng <- igraph::graph_from_data_frame(d = edges,\r\n                                   directed = TRUE,\r\n                                   vertices = nodes)\r\nplot(g, edge.label = E(g)$capacity, \r\n     main = \"Oil Pipeline Capacities\", \r\n     vertex.color = V(g)$color,\r\n     edge.color = E(g)$color)\r\n\r\n\r\n\r\nBig M\r\nIn order to model this problem, we need to put a very large capacity\r\nfrom the source node to the sink node, these\r\nare s and t mentioned above. We have given\r\nthem node names 0 and 4 respectively in the\r\ndataframe for nodes.\r\n\r\n\r\nBIG_M <- 1000000\r\n\r\nedges <- rbind(edges, data.frame(from = c(4),\r\n                                 to = c(0), \r\n                                 capacity = c(BIG_M), \r\n                                 color = \"purple\"))\r\n\r\n# Never hurts to add an id\r\nedges$id <- 0:(nrow(edges)-1)\r\n\r\ng <- igraph::graph_from_data_frame(d = edges,\r\n                                   directed = TRUE,\r\n                                   vertices = nodes)\r\nplot(g,\r\n     edge.label = E(g)$capacity, \r\n     main = \"Oil Pipeline Capacities\", \r\n     vertex.color = V(g)$color,\r\n     edge.color = E(g)$color)\r\n\r\n\r\n\r\nLinear Programming (LP)\r\nLP Structure\r\nThe next step is to set up the optimization. Let’s do that now. There\r\nare 3 key ingredients.\r\nObjective\r\nConstraints\r\nDirections\r\nConstraints\r\nWe want to build the constraint matrix, which has 2 parts.\r\nArc Capacity Constraints\r\nNode Flow Constraints\r\nThe Arc Capacity Constraints are the first we\r\naddress.\r\nThe Amat, or A matrix, is the arc matrix which contains\r\nthe upper bounds. Since linear programming relies on the resource\r\nmatrix, we need one row for each arc, our dimensions for variable flow\r\nselection are the number of arcs also. So this means we need an\r\nidentity matrix for the rows of arcs and columns of\r\narcs.\r\n\r\n\r\nAmat <- matrix(0, nrow = nrow(edges), ncol = nrow(edges))\r\nAmat_dir <- rep(\"<=\", nrow(Amat))\r\nAmat_rhs <- c()\r\n\r\nfor(i in 1:ncol(Amat)){\r\n  Amat[i,i] <- 1\r\n  Amat_rhs <- c(Amat_rhs, edges$capacity[i])\r\n}\r\n\r\nAmat\r\n\r\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7]\r\n[1,]    1    0    0    0    0    0    0\r\n[2,]    0    1    0    0    0    0    0\r\n[3,]    0    0    1    0    0    0    0\r\n[4,]    0    0    0    1    0    0    0\r\n[5,]    0    0    0    0    1    0    0\r\n[6,]    0    0    0    0    0    1    0\r\n[7,]    0    0    0    0    0    0    1\r\n\r\nAmat_rhs\r\n\r\n[1] 2e+00 3e+00 3e+00 4e+00 1e+00 2e+00 1e+06\r\n\r\nAmat_dir\r\n\r\n[1] \"<=\" \"<=\" \"<=\" \"<=\" \"<=\" \"<=\" \"<=\"\r\n\r\nThe Node Flow Constraints are the next to take care\r\nof.\r\nFor each node, we need to match it’s from node and\r\nto node with the appropriate inflow and outflow. If it\r\nmatches an inflow arc, this is increase, so 1\r\nis in the arc column. If it matches an outflow arch, this\r\nis decrease, so -1 is in the arc column. Otherwise\r\n0 remains as the placeholder. The sign here is\r\n== because they must match (i.e., supply = demand). If we\r\nrequire excess at certain points we can set this demand to be higher\r\nthan zero, but we will not do that here.\r\n\r\n\r\nBmat <- matrix(0, nrow = nrow(nodes), ncol = nrow(edges))\r\nBmat_dir <- rep(\"==\", nrow(Bmat))\r\nBmat_rhs <- rep(0, nrow(Bmat))\r\n\r\nfor(i in 1:nrow(Bmat)){\r\n  node_id <- nodes[i, \"id\"]\r\n  for(j in 1:ncol(Bmat)){\r\n    edge_from <- edges[j,\"from\"]\r\n    edge_to <- edges[j, \"to\"]\r\n    edge_id <- edges[j, \"id\"]\r\n    \r\n    if(node_id == edge_from){\r\n      Bmat[i,j] = -1\r\n    }\r\n    else if(node_id == edge_to){\r\n      Bmat[i,j] = 1\r\n    }\r\n    else{\r\n      Bmat[i,j] = 0\r\n    }\r\n  }\r\n}\r\n\r\nBmat\r\n\r\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7]\r\n[1,]   -1   -1    0    0    0    0    1\r\n[2,]    1    0   -1   -1    0    0    0\r\n[3,]    0    1    1    0    0   -1    0\r\n[4,]    0    0    0    1   -1    0    0\r\n[5,]    0    0    0    0    1    1   -1\r\n\r\nBmat_dir\r\n\r\n[1] \"==\" \"==\" \"==\" \"==\" \"==\"\r\n\r\nBmat_rhs\r\n\r\n[1] 0 0 0 0 0\r\n\r\nObjective\r\nNext, the objective is going to be 0 for all values,\r\nexcept our final flow. This we want to maximize.\r\n\r\n\r\nf.obj <- c(rep(0, nrow(edges)-1), 1)\r\nf.obj\r\n\r\n[1] 0 0 0 0 0 0 1\r\n\r\nSolve the LP\r\nNow we unite everything together and drop it into the solver.\r\nRemember, we are trying to maximize flow. So specify\r\nmax.\r\n\r\n\r\nf.cons <- rbind(Amat, Bmat)\r\nf.rhs <- c(Amat_rhs, Bmat_rhs)\r\nf.dir <- c(Amat_dir, Bmat_dir)\r\n\r\nresults <- lp(direction = \"max\",  \r\n              objective.in = f.obj, \r\n              const.mat = f.cons, \r\n              const.dir = f.dir, \r\n              const.rhs = f.rhs)\r\nresults$solution\r\n\r\n[1] 1 2 0 1 1 2 3\r\n\r\nVisualize Maximum Flow\r\nSolution\r\nSince the results$solution contain the maximum flow we\r\ncan push through the pipes as a system, we can add this into our flow\r\ncomponent of the edges dataframe.\r\nThe visual indicates that 2/3 of the capacity was\r\nshipped to node 2, and 1/2 to\r\nnode 1. After this the next best transfer was from\r\nnode 2 to node 4 maxed out at\r\n2/2. This is indicated in red. The arcs that have flow are\r\nindicated in black, and no flow is indicated by grey. The maximum flow\r\narc is just an artificial arc that indicates the maximum\r\nflow, this is indicated in purple.\r\nLastly from the node 1 to node 3\r\n1/4 of the capacity was sent. Then from node 3\r\nto node 4 was maxed out at 1/1.\r\nPosterior analysis to this model output tells us that sending\r\n2 million tons of oil from the source to\r\ndestination 2 and 1 million tons of oil from\r\nthe source to destination 1 will push as much\r\nflow to destination 4 as we possibly can.\r\n\r\n\r\n# Set the flow\r\nedges$flow <- results$solution\r\n\r\n# If the arc is flowing oil, change to black\r\nedges$color[which(edges$flow > 0)] <- \"black\"\r\n\r\n# If the arc is at capacity change it to red\r\nedges$color[which(edges$flow == edges$capacity)] <- \"red\"\r\n\r\n# Last flow is purple\r\nedges$color[nrow(edges)] <- \"purple\"\r\n\r\n\r\ng <- igraph::graph_from_data_frame(d = edges,\r\n                                   directed = TRUE,\r\n                                   vertices = nodes)\r\n\r\n# Make it look a little more appealing\r\nL = cbind(1:5, 1:5)\r\nCURVE = c(0,0.15, 0.3, 0.45, 0, -0.15, -0.3, 0, 0.15, 0) * 5\r\n\r\n# Plot\r\nplot(g,\r\n     layout = L,\r\n     edge.curved = CURVE,\r\n     edge.label = paste(\"(\",E(g)$flow, \r\n                        \",\", \r\n                        E(g)$capacity, \")\", \r\n                        sep=\"\"), \r\n     main = \"Oil Pipeline Flow | (flow, capacity)\", \r\n     vertex.color = V(g)$color,\r\n     vertex.size = 25,\r\n     vertex.label.cex = 1.6,\r\n     edge.color = E(g)$color,\r\n     edge.width = E(g)$flow*2)\r\n\r\n\r\n\r\nCleaning Up The Visual\r\n\r\n\r\nvisNet_nodes <- nodes %>% \r\n                dplyr::mutate(label = paste(\"Location \", id),\r\n                              font.size =10,\r\n                              type = \"black\",\r\n                              shape = \"circle\",\r\n                              font = 12)\r\n\r\nvisNet_edges <- edges %>% \r\n                dplyr::mutate(label = paste(\"(\",flow,\",\",capacity,\")\",sep=\"\"),\r\n                              length = 250,\r\n                              width = flow*2,\r\n                              arrows = \"to\") \r\n  \r\nvisNetwork(visNet_nodes, \r\n           visNet_edges,\r\n           width = \"100%\",\r\n           main = \"Maximum Oil Flow | (flow, capacity)\")\r\n\r\n\r\n\r\nReferences\r\nExample taken from the following sources:\r\nWinston., Wayne. Operations Research, Applications and\r\nAlgorithms 4th Edition.\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-07-09-maximum-network-flows-in-r/maximum-network-flows-in-r_files/figure-html5/initial_graph-1.png",
    "last_modified": "2022-07-10T09:03:29-04:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-07-09-shortest-path-optimization-in-r/",
    "title": "Shortest Path Optimization in R",
    "description": "In this post we will walk through how to make least cost decisions using network flows shortest path algorithm.",
    "author": [
      {
        "name": "Blake Conrad",
        "url": "https://github.com/conradbm"
      }
    ],
    "date": "2022-07-09",
    "categories": [],
    "contents": "\r\n\r\nContents\r\nVehicle\r\nReplacement Using Shortest Path\r\nProblem Setup\r\nProblem Data\r\nNew Car Cost\r\nMaintenance Costs\r\nTrade-in Revenues\r\nCost Matrix\r\n\r\nSolving the Problem\r\nVisualizing the network\r\nShortest Path Solution\r\nShortest Path Analysis\r\n\r\n\r\nReferences\r\n\r\nVehicle Replacement\r\nUsing Shortest Path\r\nA common problem we often face in the world is to find the shortest\r\npath between two points. Whether it is on the road, or how to obtain an\r\nobject in in our intellectual trajectory, we are always seeking to\r\noptimize.\r\nIn network flows one common problem is to find the\r\ns-t shortest path. The problem formulation is as\r\nfollows.\r\nGiven some net of nodes, and two particular nodes s and\r\nt that are not the same, find the shortest distance through\r\nthe edges connecting them. The mathematical formulation is below. \\[ N \\in \\{n_1, n_2, .., n_D\\} \\] \\[ E = \\{N \\times N\\} = \\{e_{ij} \\in \\Re^+ |\r\n\\:\\:\\forall i,j \\in N \\} \\] \\[ s,t \\in\r\nN : s\\neq t\\]\r\nProblem Setup\r\nWe all have to drive cars at some point in our adult lives (well,\r\nmost of us). With this comes the question of investment\r\ndecisions if I am allowed to call it that. Which car should we buy?\r\nHow long should we keep it? Is it more prudent to keep paying\r\nmaintenance, repairs, and damages, or just get a new ride?\r\nWe would like to know what is the best decision to make over the next\r\n5 years for our vehicle needs. So we take this problem and model it as\r\nan optimization problem using the famous\r\nshortest paths algorithm.\r\nSo with our problem the decision space is pretty straight\r\nforward:\r\nEach year we can choose to keep our vehicle, or\r\nTrade it in\r\nHowever, every year we choose to keep our vehicle, we must pay\r\nmaintenance costs for it. So every year we keep it, there is a\r\ncumulative maintenance cost. Once we trade-in we offset the cost of the\r\nnew car with the trade in value, and pay much less maintenance on the\r\nnew ride. Let’s take a look at the problem data.\r\nProblem Data\r\nWe know the cost every year of a new vehicle is assumed as\r\n$12,000 for simplicity. Further, we have some records of\r\nwhat maintenance costs and trade-in values will be.\r\nNew Car Cost\r\nThe new car cost is assumed constant every year. An interesting\r\nhomework assignment would be to make this stochastic and\r\nchange over time. This is much more suitable to the real world, but for\r\nthis example will remain constant.\r\n\r\n\r\nNEW_CAR_COST <- 12000\r\nNEW_CAR_COST\r\n\r\n[1] 12000\r\n\r\nMaintenance Costs\r\nThe maintenance costs are for 4 years. Each year you keep the car,\r\nyou will pay more on maintenance.\r\n\r\n\r\nM <- data.frame(Year = c(0:4), Maintenance_cost = c(2000, 4000, 5000, 9000, 12000))\r\nM_vec <- M %>% dplyr::pull(Maintenance_cost)\r\nM\r\n\r\n  Year Maintenance_cost\r\n1    0             2000\r\n2    1             4000\r\n3    2             5000\r\n4    3             9000\r\n5    4            12000\r\n\r\nTrade-in Revenues\r\nThe trade-in price is similar to maintenance. Each year you keep the\r\nvehicle, it will depreciate. So to account for this we have a decreasing\r\ntrade-in value.\r\n\r\n\r\nT <- data.frame(Year = c(1:5), Trade_in_price = c(7000, 6000, 2000, 1000, 0))\r\nT_vec <- T %>% dplyr::pull(Trade_in_price)\r\nT\r\n\r\n  Year Trade_in_price\r\n1    1           7000\r\n2    2           6000\r\n3    3           2000\r\n4    4           1000\r\n5    5              0\r\n\r\nCost Matrix\r\nSince we know the costs will be cumulative, so we know what each\r\nyears will be. The cost matrix will be for the number of years the car\r\nis kept to accumulate costs from maintenance. In mathematical language,\r\nthis is represented below:\r\n\\[ c_{ij} = \\sum_{t=1}^{j-1}{M_{t-1}}\\:\\:\r\nif\\: j > i \\:\\: otherwise \\: \\infty \\]\r\nWhere M is the maintenance matrix defined above.\r\nWe also know our objective is to minimize the total cost, which\r\nequates to maintanence cost +\r\ncost to purchase a new car -\r\ntrade in value.\r\n\r\n\r\n# Nodes dataframe\r\nnodes = data.frame(Year = c(sprintf(\"Year %s\", seq(1:6))),\r\n                   Color = c(\"green\", \"gold\", \"gold\", \"gold\", \"gold\", \"red\"))\r\nn = nrow(nodes)\r\n\r\n# Edges list\r\nedges = list(from=c(), to=c(), cost=c(), color=c())\r\n\r\n# Cost matrix\r\nC <- matrix(0, n, n)\r\nBIG_M <- 1000000\r\nfor(i in 1:n){\r\n  for (j in 1:n){\r\n    if(j > i){\r\n      \r\n      # Cost of maintenance\r\n      maintenance_cost <- M_vec[1:(j-i)]\r\n      maintenance_cost_total <- sum(maintenance_cost)\r\n\r\n      # Cost of new car\r\n      new_car_cost = NEW_CAR_COST\r\n      \r\n      # Trade-in value\r\n      trade_in_revenue <- T_vec[j-i]\r\n\r\n      # Total cost for decision to buy car on year i and sell it on year j\r\n      total_cost_for_decision_i_to_j <- new_car_cost + maintenance_cost_total - trade_in_revenue\r\n\r\n      # Save the value into cost matrix\r\n      C[i,j] <- total_cost_for_decision_i_to_j\r\n      edges$from <- append(edges$from, paste(\"Year\", i))\r\n      edges$to <- append(edges$to, paste(\"Year\", j))\r\n      edges$cost <- append(edges$cost, total_cost_for_decision_i_to_j)\r\n      edges$color <- append(edges$color, \"grey\")\r\n    }\r\n    else{\r\n      \r\n      # Big M otherwise to make edge infeasible\r\n      C[i,j] <- BIG_M\r\n    }\r\n  }\r\n}\r\n\r\n# Edges dataframe\r\nedges <- edges %>% as.data.frame\r\n\r\nnodes\r\n\r\n    Year Color\r\n1 Year 1 green\r\n2 Year 2  gold\r\n3 Year 3  gold\r\n4 Year 4  gold\r\n5 Year 5  gold\r\n6 Year 6   red\r\n\r\nedges\r\n\r\n     from     to  cost color\r\n1  Year 1 Year 2  7000  grey\r\n2  Year 1 Year 3 12000  grey\r\n3  Year 1 Year 4 21000  grey\r\n4  Year 1 Year 5 31000  grey\r\n5  Year 1 Year 6 44000  grey\r\n6  Year 2 Year 3  7000  grey\r\n7  Year 2 Year 4 12000  grey\r\n8  Year 2 Year 5 21000  grey\r\n9  Year 2 Year 6 31000  grey\r\n10 Year 3 Year 4  7000  grey\r\n11 Year 3 Year 5 12000  grey\r\n12 Year 3 Year 6 21000  grey\r\n13 Year 4 Year 5  7000  grey\r\n14 Year 4 Year 6 12000  grey\r\n15 Year 5 Year 6  7000  grey\r\n\r\nC\r\n\r\n      [,1]  [,2]    [,3]    [,4]    [,5]    [,6]\r\n[1,] 1e+06 7e+03   12000   21000   31000   44000\r\n[2,] 1e+06 1e+06    7000   12000   21000   31000\r\n[3,] 1e+06 1e+06 1000000    7000   12000   21000\r\n[4,] 1e+06 1e+06 1000000 1000000    7000   12000\r\n[5,] 1e+06 1e+06 1000000 1000000 1000000    7000\r\n[6,] 1e+06 1e+06 1000000 1000000 1000000 1000000\r\n\r\nSolving the Problem\r\nNow that we have our cost matrix, the last ingredient is to solve the\r\nproblem. That means to solve the s-t shortest path from\r\nYear 0 to Year 6, so we can determine what is\r\nthe cheapest investment strategy for us. For this, we will be using the\r\nigraph package.\r\nVisualizing the network\r\n\r\n\r\ng <- igraph::graph_from_data_frame(d = edges,\r\n                                   directed = TRUE,\r\n                                   vertices = nodes)\r\n# Make it a little cleaner\r\nplot(g,\r\n     main = \"Cost of Annual Vehicle Trade-in\",\r\n     edge.arrow.size=.5,\r\n     vertex.color=V(g)$Color,\r\n     edge.color=E(g)$color,\r\n     edge.label = E(g)$cost,\r\n     edge.width = E(g)$cost/10000,\r\n     vertex.size=20,\r\n     vertex.frame.color=\"gray\",\r\n     vertex.label.color=\"black\",\r\n     vertex.label.cex=0.8,\r\n     vertex.label.dist=2, layout = layout_as_star,\r\n     edge.curved=0.2)\r\n\r\n\r\n\r\nShortest Path Solution\r\nSo once we perform the Dijkstra's Shortest Path\r\nalgorithm on the network we obtain a solution in matrix form. This\r\nsolution tells us the best possible cost for our car decision from\r\nYear 1 to Year 6 will be at\r\n$31,000.\r\nWhat this does not show us is what path was chosen to obtain that\r\nvalue.\r\n\r\n\r\n# Get the shortest paht cost matrix\r\ns_paths_cost <- igraph::shortest.paths(graph = g, v = V(g), weights = E(g)$cost, algorithm = \"dijkstra\")\r\ns_paths_cost\r\n\r\n       Year 1 Year 2 Year 3 Year 4 Year 5 Year 6\r\nYear 1      0   7000  12000  19000  24000  31000\r\nYear 2   7000      0   7000  12000  19000  24000\r\nYear 3  12000   7000      0   7000  12000  19000\r\nYear 4  19000  12000   7000      0   7000  12000\r\nYear 5  24000  19000  12000   7000      0   7000\r\nYear 6  31000  24000  19000  12000   7000      0\r\n\r\nShortest Path Analysis\r\nThe optimal selection is the following sequence:\r\nBuy a new car in Year 1 keep the car for a year, then\r\nsell on Year 2.\r\nBuy another car in Year 2, but keep for two years and\r\nsell on Year 4.\r\nFinally, buy a car on Year 4, keep for two years and\r\nsell on Year 6.\r\nDo these numbers add up? Let’s check. 7000 + 12000 + 12000 == 31000\r\nis TRUE.\r\nSo our least cost strategy can be no less than $31000\r\nover the next 6 years. With the current cost structure, means to keep\r\nthe car for a year or two, then pitch it because the trade-off between\r\nmaintenance accumulation and depreciation start to mutually deter from a\r\nleast cost decision.\r\n\r\n\r\n# Get all path distances solution vertex path\r\ns.paths <- igraph::shortest_paths(graph = g,\r\n                                  from = \"Year 1\",\r\n                                  output = \"vpath\",\r\n                                  weights = E(g)$cost, \r\n                                  to = \"Year 6\")\r\n                                  # v = V(g), \r\n                                  # to = V(g), \r\n                                  # weights = E(g)$cost)\r\n\r\n# Update colors from vertex path found\r\ns.paths$vpath\r\n\r\n[[1]]\r\n+ 4/6 vertices, named, from 626e7cd:\r\n[1] Year 1 Year 2 Year 4 Year 6\r\n\r\nE(g, path = s.paths$vpath[[1]])$color <- \"red\"\r\n\r\n\r\n\r\n\r\nplot(g,\r\n     main = \"Least Cost Vehicle Trade-in Policy\",\r\n     edge.arrow.size=.5,\r\n     vertex.color=V(g)$Color,\r\n     edge.color=E(g)$color,\r\n     edge.label = E(g)$cost,\r\n     edge.width = E(g)$cost/10000,\r\n     vertex.size=20,\r\n     vertex.frame.color=\"gray\",\r\n     vertex.label.color=\"black\",\r\n     vertex.label.cex=0.8,\r\n     vertex.label.dist=2, layout = layout_as_star,\r\n     edge.curved=0.2)\r\n\r\n\r\n\r\nThis plot doesn’t look too great! Let’s try to spruce it up a bit\r\nusing visNetwork, a common package in R that leverages the\r\nvis.js framework, which can be found here.\r\n\r\n\r\nV(g)$label = nodes$Year\r\nV(g)$shape = \"circle\"\r\nE(g)$width = edges$cost/10000\r\nE(g)$weight = edges$cost/10000\r\nE(g)$label = edges$cost %>% as.character\r\n\r\nvisIgraph(igraph = g)\r\n\r\n\r\n\r\nReferences\r\nExample taken from the following sources:\r\nWinston., Wayne. Operations Research, Applications and\r\nAlgorithms 4th Edition.\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-07-09-shortest-path-optimization-in-r/shortest-path-optimization-in-r_files/figure-html5/viz_network-1.png",
    "last_modified": "2022-07-10T09:15:37-04:00",
    "input_file": {}
  },
  {
    "path": "posts/welcome/",
    "title": "Welcome to Optimization Daily",
    "description": "Welcome to Optimization Daily! Grab a coffee, take a read, and enjoy your stay.",
    "author": [
      {
        "name": "Blake Conrad",
        "url": "https://github.com/conradbm"
      }
    ],
    "date": "2022-07-09",
    "categories": [],
    "contents": "\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-07-10T09:09:22-04:00",
    "input_file": {}
  }
]
