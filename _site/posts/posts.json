[
  {
    "path": "posts/welcome/",
    "title": "Welcome to Optimization Daily",
    "description": "Welcome to Optimization Daily! Grab a coffee, take a read, and enjoy your stay.",
    "author": [
      {
        "name": "Blake Conrad",
        "url": "https://github.com/conradbm"
      }
    ],
    "date": "2022-07-09",
    "categories": [],
    "contents": "\r\n\r\n\r\n\r\n",
    "preview": {},
    "last_modified": "2022-07-10T08:49:57-04:00",
    "input_file": "welcome.knit.md"
  },
  {
    "path": "posts/2022-07-09-shortest-path-optimization-in-r/",
    "title": "Shortest Path Optimization in R",
    "description": "In this post we will walk through how to make least cost decisions using network flows shortest path algorithm.",
    "author": [
      {
        "name": "Blake Conrad",
        "url": "https://github.com/conradbm"
      }
    ],
    "date": "2022-07-09",
    "categories": [],
    "contents": "\r\n\r\nContents\r\nVehicle\r\nReplacement Using Shortest Path\r\nProblem Setup\r\nProblem Data\r\nNew Car Cost\r\nMaintenance Costs\r\nTrade-in Revenues\r\nCost Matrix\r\n\r\nSolving the Problem\r\nVisualizing the network\r\nShortest Path Solution\r\nShortest Path Analysis\r\n\r\n\r\nReferences\r\n\r\nVehicle Replacement\r\nUsing Shortest Path\r\nA common problem we often face in the world is to find the shortest\r\npath between two points. Whether it is on the road, or how to obtain an\r\nobject in in our intellectual trajectory, we are always seeking to\r\noptimize.\r\nIn network flows one common problem is to find the\r\ns-t shortest path. The problem formulation is as\r\nfollows.\r\nGiven some net of nodes, and two particular nodes s and\r\nt that are not the same, find the shortest distance through\r\nthe edges connecting them. The mathematical formulation is below. \\[ N \\in \\{n_1, n_2, .., n_D\\} \\] \\[ E = \\{N \\times N\\} = \\{e_{ij} \\in \\Re^+ |\r\n\\:\\:\\forall i,j \\in N \\} \\] \\[ s,t \\in\r\nN : s\\neq t\\]\r\nProblem Setup\r\nWe all have to drive cars at some point in our adult lives (well,\r\nmost of us). With this comes the question of investment\r\ndecisions if I am allowed to call it that. Which car should we buy?\r\nHow long should we keep it? Is it more prudent to keep paying\r\nmaintenance, repairs, and damages, or just get a new ride?\r\nWe would like to know what is the best decision to make over the next\r\n5 years for our vehicle needs. So we take this problem and model it as\r\nan optimization problem using the famous\r\nshortest paths algorithm.\r\nSo with our problem the decision space is pretty straight\r\nforward:\r\nEach year we can choose to keep our vehicle, or\r\nTrade it in\r\nHowever, every year we choose to keep our vehicle, we must pay\r\nmaintenance costs for it. So every year we keep it, there is a\r\ncumulative maintenance cost. Once we trade-in we offset the cost of the\r\nnew car with the trade in value, and pay much less maintenance on the\r\nnew ride. Let’s take a look at the problem data.\r\nProblem Data\r\nWe know the cost every year of a new vehicle is assumed as\r\n$12,000 for simplicity. Further, we have some records of\r\nwhat maintenance costs and trade-in values will be.\r\nNew Car Cost\r\nThe new car cost is assumed constant every year. An interesting\r\nhomework assignment would be to make this stochastic and\r\nchange over time. This is much more suitable to the real world, but for\r\nthis example will remain constant.\r\n\r\n\r\nNEW_CAR_COST <- 12000\r\nNEW_CAR_COST\r\n\r\n[1] 12000\r\n\r\nMaintenance Costs\r\nThe maintenance costs are for 4 years. Each year you keep the car,\r\nyou will pay more on maintenance.\r\n\r\n\r\nM <- data.frame(Year = c(0:4), Maintenance_cost = c(2000, 4000, 5000, 9000, 12000))\r\nM_vec <- M %>% dplyr::pull(Maintenance_cost)\r\nM\r\n\r\n  Year Maintenance_cost\r\n1    0             2000\r\n2    1             4000\r\n3    2             5000\r\n4    3             9000\r\n5    4            12000\r\n\r\nTrade-in Revenues\r\nThe trade-in price is similar to maintenance. Each year you keep the\r\nvehicle, it will depreciate. So to account for this we have a decreasing\r\ntrade-in value.\r\n\r\n\r\nT <- data.frame(Year = c(1:5), Trade_in_price = c(7000, 6000, 2000, 1000, 0))\r\nT_vec <- T %>% dplyr::pull(Trade_in_price)\r\nT\r\n\r\n  Year Trade_in_price\r\n1    1           7000\r\n2    2           6000\r\n3    3           2000\r\n4    4           1000\r\n5    5              0\r\n\r\nCost Matrix\r\nSince we know the costs will be cumulative, so we know what each\r\nyears will be. The cost matrix will be for the number of years the car\r\nis kept to accumulate costs from maintenance. In mathematical language,\r\nthis is represented below:\r\n\\[ c_{ij} = \\sum_{t=1}^{j-1}{M_{t-1}}\\:\\:\r\nif\\: j > i \\:\\: otherwise \\: \\infty \\]\r\nWhere M is the maintenance matrix defined above.\r\nWe also know our objective is to minimize the total cost, which\r\nequates to maintanence cost +\r\ncost to purchase a new car -\r\ntrade in value.\r\n\r\n\r\n# Nodes dataframe\r\nnodes = data.frame(Year = c(sprintf(\"Year %s\", seq(1:6))),\r\n                   Color = c(\"green\", \"gold\", \"gold\", \"gold\", \"gold\", \"red\"))\r\nn = nrow(nodes)\r\n\r\n# Edges list\r\nedges = list(from=c(), to=c(), cost=c(), color=c())\r\n\r\n# Cost matrix\r\nC <- matrix(0, n, n)\r\nBIG_M <- 1000000\r\nfor(i in 1:n){\r\n  for (j in 1:n){\r\n    if(j > i){\r\n      \r\n      # Cost of maintenance\r\n      maintenance_cost <- M_vec[1:(j-i)]\r\n      maintenance_cost_total <- sum(maintenance_cost)\r\n\r\n      # Cost of new car\r\n      new_car_cost = NEW_CAR_COST\r\n      \r\n      # Trade-in value\r\n      trade_in_revenue <- T_vec[j-i]\r\n\r\n      # Total cost for decision to buy car on year i and sell it on year j\r\n      total_cost_for_decision_i_to_j <- new_car_cost + maintenance_cost_total - trade_in_revenue\r\n\r\n      # Save the value into cost matrix\r\n      C[i,j] <- total_cost_for_decision_i_to_j\r\n      edges$from <- append(edges$from, paste(\"Year\", i))\r\n      edges$to <- append(edges$to, paste(\"Year\", j))\r\n      edges$cost <- append(edges$cost, total_cost_for_decision_i_to_j)\r\n      edges$color <- append(edges$color, \"grey\")\r\n    }\r\n    else{\r\n      \r\n      # Big M otherwise to make edge infeasible\r\n      C[i,j] <- BIG_M\r\n    }\r\n  }\r\n}\r\n\r\n# Edges dataframe\r\nedges <- edges %>% as.data.frame\r\n\r\nnodes\r\n\r\n    Year Color\r\n1 Year 1 green\r\n2 Year 2  gold\r\n3 Year 3  gold\r\n4 Year 4  gold\r\n5 Year 5  gold\r\n6 Year 6   red\r\n\r\nedges\r\n\r\n     from     to  cost color\r\n1  Year 1 Year 2  7000  grey\r\n2  Year 1 Year 3 12000  grey\r\n3  Year 1 Year 4 21000  grey\r\n4  Year 1 Year 5 31000  grey\r\n5  Year 1 Year 6 44000  grey\r\n6  Year 2 Year 3  7000  grey\r\n7  Year 2 Year 4 12000  grey\r\n8  Year 2 Year 5 21000  grey\r\n9  Year 2 Year 6 31000  grey\r\n10 Year 3 Year 4  7000  grey\r\n11 Year 3 Year 5 12000  grey\r\n12 Year 3 Year 6 21000  grey\r\n13 Year 4 Year 5  7000  grey\r\n14 Year 4 Year 6 12000  grey\r\n15 Year 5 Year 6  7000  grey\r\n\r\nC\r\n\r\n      [,1]  [,2]    [,3]    [,4]    [,5]    [,6]\r\n[1,] 1e+06 7e+03   12000   21000   31000   44000\r\n[2,] 1e+06 1e+06    7000   12000   21000   31000\r\n[3,] 1e+06 1e+06 1000000    7000   12000   21000\r\n[4,] 1e+06 1e+06 1000000 1000000    7000   12000\r\n[5,] 1e+06 1e+06 1000000 1000000 1000000    7000\r\n[6,] 1e+06 1e+06 1000000 1000000 1000000 1000000\r\n\r\nSolving the Problem\r\nNow that we have our cost matrix, the last ingredient is to solve the\r\nproblem. That means to solve the s-t shortest path from\r\nYear 0 to Year 6, so we can determine what is\r\nthe cheapest investment strategy for us. For this, we will be using the\r\nigraph package.\r\nVisualizing the network\r\n\r\n\r\ng <- igraph::graph_from_data_frame(d = edges,\r\n                                   directed = TRUE,\r\n                                   vertices = nodes)\r\n# Make it a little cleaner\r\nplot(g,\r\n     main = \"Cost of Annual Vehicle Trade-in\",\r\n     edge.arrow.size=.5,\r\n     vertex.color=V(g)$Color,\r\n     edge.color=E(g)$color,\r\n     edge.label = E(g)$cost,\r\n     edge.width = E(g)$cost/10000,\r\n     vertex.size=20,\r\n     vertex.frame.color=\"gray\",\r\n     vertex.label.color=\"black\",\r\n     vertex.label.cex=0.8,\r\n     vertex.label.dist=2, layout = layout_as_star,\r\n     edge.curved=0.2)\r\n\r\n\r\n\r\nShortest Path Solution\r\nSo once we perform the Dijkstra's Shortest Path\r\nalgorithm on the network we obtain a solution in matrix form. This\r\nsolution tells us the best possible cost for our car decision from\r\nYear 1 to Year 6 will be at\r\n$31,000.\r\nWhat this does not show us is what path was chosen to obtain that\r\nvalue.\r\n\r\n\r\n# Get the shortest paht cost matrix\r\ns_paths_cost <- igraph::shortest.paths(graph = g, v = V(g), weights = E(g)$cost, algorithm = \"dijkstra\")\r\ns_paths_cost\r\n\r\n       Year 1 Year 2 Year 3 Year 4 Year 5 Year 6\r\nYear 1      0   7000  12000  19000  24000  31000\r\nYear 2   7000      0   7000  12000  19000  24000\r\nYear 3  12000   7000      0   7000  12000  19000\r\nYear 4  19000  12000   7000      0   7000  12000\r\nYear 5  24000  19000  12000   7000      0   7000\r\nYear 6  31000  24000  19000  12000   7000      0\r\n\r\nShortest Path Analysis\r\nThe optimal selection is the following sequence:\r\nBuy a new car in Year 1 keep the car for a year, then\r\nsell on Year 2.\r\nBuy another car in Year 2, but keep for two years and\r\nsell on Year 4.\r\nFinally, buy a car on Year 4, keep for two years and\r\nsell on Year 6.\r\nDo these numbers add up? Let’s check. 7000 + 12000 + 12000 == 31000\r\nis TRUE.\r\nSo our least cost strategy can be no less than $31000\r\nover the next 6 years. With the current cost structure, means to keep\r\nthe car for a year or two, then pitch it because the trade-off between\r\nmaintenance accumulation and depreciation start to mutually deter from a\r\nleast cost decision.\r\n\r\n\r\n# Get all path distances solution vertex path\r\ns.paths <- igraph::shortest_paths(graph = g,\r\n                                  from = \"Year 1\",\r\n                                  output = \"vpath\",\r\n                                  weights = E(g)$cost, \r\n                                  to = \"Year 6\")\r\n                                  # v = V(g), \r\n                                  # to = V(g), \r\n                                  # weights = E(g)$cost)\r\n\r\n# Update colors from vertex path found\r\ns.paths$vpath\r\n\r\n[[1]]\r\n+ 4/6 vertices, named, from aaffe9a:\r\n[1] Year 1 Year 2 Year 4 Year 6\r\n\r\nE(g, path = s.paths$vpath[[1]])$color <- \"red\"\r\n\r\n\r\n\r\n\r\nplot(g,\r\n     main = \"Least Cost Vehicle Trade-in Policy\",\r\n     edge.arrow.size=.5,\r\n     vertex.color=V(g)$Color,\r\n     edge.color=E(g)$color,\r\n     edge.label = E(g)$cost,\r\n     edge.width = E(g)$cost/10000,\r\n     vertex.size=20,\r\n     vertex.frame.color=\"gray\",\r\n     vertex.label.color=\"black\",\r\n     vertex.label.cex=0.8,\r\n     vertex.label.dist=2, layout = layout_as_star,\r\n     edge.curved=0.2)\r\n\r\n\r\n\r\nThis plot doesn’t look too great! Let’s try to spruce it up a bit\r\nusing visNetwork, a common package in R that leverages the\r\nvis.js framework, which can be found here.\r\n\r\n\r\nV(g)$label = nodes$Year\r\nV(g)$shape = \"circle\"\r\nE(g)$width = edges$cost/10000\r\nE(g)$weight = edges$cost/10000\r\nE(g)$label = edges$cost %>% as.character\r\n\r\nvisIgraph(igraph = g)\r\n\r\n\r\n\r\nReferences\r\nExample taken from the following sources:\r\nWinston., Wayne. Operations Research, Applications and\r\nAlgorithms 4th Edition.\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-07-09-shortest-path-optimization-in-r/shortest-path-optimization-in-r_files/figure-html5/viz_network-1.png",
    "last_modified": "2022-07-10T09:03:19-04:00",
    "input_file": "shortest-path-optimization-in-r.knit.md"
  },
  {
    "path": "posts/2022-07-09-maximum-network-flows-in-r/",
    "title": "Maximum Network Flows in R",
    "description": "In this post we will walk through how to make a maximum flow decision using network flows and linear programming.",
    "author": [
      {
        "name": "Blake Conrad",
        "url": "https://github.com/conradbm"
      }
    ],
    "date": "2022-07-09",
    "categories": [],
    "contents": "\r\n\r\nContents\r\nOil Flow Maximization\r\nProblem Formation\r\nNetwork Structure\r\nNetwork Visual\r\nBig M\r\n\r\nLinear Programming (LP)\r\nLP Structure\r\nConstraints\r\nObjective\r\n\r\nSolve the LP\r\nVisualize Maximum Flow\r\nSolution\r\nCleaning Up The Visual\r\n\r\n\r\nReferences\r\n\r\nOil Flow Maximization\r\nOne classic problem in Network Flows and\r\nOptimization is called the Max-Flow Problem.\r\nThis takes any two nodes in a network, s and t\r\nand attempts to send as much of a resource (or multiple) from\r\ns to t. This is called a flow,\r\nand the flow which maximizes the total bandwidth of the network is\r\ncalled the maximum flow.\r\nFirst, the problem starts with an objective: to\r\nmaximize flow. These are denoted as,\r\n\\[x_{ij} = flow \\: on \\: node_i \\: to \\:\r\nnode_j \\:(or \\: on \\: arc \\: (i,j))\\]\r\nSecond, the problem has a set of constraints, these are called the\r\narc capacities. These are denoted as,\r\n\\[u_{ij} = maximum \\:amount \\:of \\:\r\nfeasible \\: flow \\: on \\: node_i \\: to \\: node_j \\:(or \\: on \\: arc \\:\r\n(i,j))\\] Last, the network graph is supplied as a set of\r\nconnections under the traditional network structure:\r\n\\[ G = (N,E) \\]\r\nProblem Formation\r\nFor our problem, the feasible flow is going to be in units of\r\nmillions of barrels of oil per hour that will pass through an arc of\r\npipeline.\r\nNetwork Structure\r\nThe source for our network is indicated in green and sink in red.\r\n\r\n\r\nnodes <- data.frame(id = c(0:4), color = c(\"green\", rep(\"grey\", 3), \"red\"))\r\nedges <- data.frame(from = c(0,0,1,1,3,2), to = c(1,2,2,3,4,4), capacity = c(2,3,3,4,1,2), color = \"grey\")\r\n\r\nedges\r\n\r\n  from to capacity color\r\n1    0  1        2  grey\r\n2    0  2        3  grey\r\n3    1  2        3  grey\r\n4    1  3        4  grey\r\n5    3  4        1  grey\r\n6    2  4        2  grey\r\n\r\nNetwork Visual\r\n\r\n\r\ng <- igraph::graph_from_data_frame(d = edges,\r\n                                   directed = TRUE,\r\n                                   vertices = nodes)\r\nplot(g, edge.label = E(g)$capacity, \r\n     main = \"Oil Pipeline Capacities\", \r\n     vertex.color = V(g)$color,\r\n     edge.color = E(g)$color)\r\n\r\n\r\n\r\nBig M\r\nIn order to model this problem, we need to put a very large capacity\r\nfrom the source node to the sink node, these\r\nare s and t mentioned above. We have given\r\nthem node names 0 and 4 respectively in the\r\ndataframe for nodes.\r\n\r\n\r\nBIG_M <- 1000000\r\n\r\nedges <- rbind(edges, data.frame(from = c(4),\r\n                                 to = c(0), \r\n                                 capacity = c(BIG_M), \r\n                                 color = \"purple\"))\r\n\r\n# Never hurts to add an id\r\nedges$id <- 0:(nrow(edges)-1)\r\n\r\ng <- igraph::graph_from_data_frame(d = edges,\r\n                                   directed = TRUE,\r\n                                   vertices = nodes)\r\nplot(g,\r\n     edge.label = E(g)$capacity, \r\n     main = \"Oil Pipeline Capacities\", \r\n     vertex.color = V(g)$color,\r\n     edge.color = E(g)$color)\r\n\r\n\r\n\r\nLinear Programming (LP)\r\nLP Structure\r\nThe next step is to set up the optimization. Let’s do that now. There\r\nare 3 key ingredients.\r\nObjective\r\nConstraints\r\nDirections\r\nConstraints\r\nWe want to build the constraint matrix, which has 2 parts.\r\nArc Capacity Constraints\r\nNode Flow Constraints\r\nThe Arc Capacity Constraints are the first we\r\naddress.\r\nThe Amat, or A matrix, is the arc matrix which contains\r\nthe upper bounds. Since linear programming relies on the resource\r\nmatrix, we need one row for each arc, our dimensions for variable flow\r\nselection are the number of arcs also. So this means we need an\r\nidentity matrix for the rows of arcs and columns of\r\narcs.\r\n\r\n\r\nAmat <- matrix(0, nrow = nrow(edges), ncol = nrow(edges))\r\nAmat_dir <- rep(\"<=\", nrow(Amat))\r\nAmat_rhs <- c()\r\n\r\nfor(i in 1:ncol(Amat)){\r\n  Amat[i,i] <- 1\r\n  Amat_rhs <- c(Amat_rhs, edges$capacity[i])\r\n}\r\n\r\nAmat\r\n\r\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7]\r\n[1,]    1    0    0    0    0    0    0\r\n[2,]    0    1    0    0    0    0    0\r\n[3,]    0    0    1    0    0    0    0\r\n[4,]    0    0    0    1    0    0    0\r\n[5,]    0    0    0    0    1    0    0\r\n[6,]    0    0    0    0    0    1    0\r\n[7,]    0    0    0    0    0    0    1\r\n\r\nAmat_rhs\r\n\r\n[1] 2e+00 3e+00 3e+00 4e+00 1e+00 2e+00 1e+06\r\n\r\nAmat_dir\r\n\r\n[1] \"<=\" \"<=\" \"<=\" \"<=\" \"<=\" \"<=\" \"<=\"\r\n\r\nThe Node Flow Constraints are the next to take care\r\nof.\r\nFor each node, we need to match it’s from node and\r\nto node with the appropriate inflow and outflow. If it\r\nmatches an inflow arc, this is increase, so 1\r\nis in the arc column. If it matches an outflow arch, this\r\nis decrease, so -1 is in the arc column. Otherwise\r\n0 remains as the placeholder. The sign here is\r\n== because they must match (i.e., supply = demand). If we\r\nrequire excess at certain points we can set this demand to be higher\r\nthan zero, but we will not do that here.\r\n\r\n\r\nBmat <- matrix(0, nrow = nrow(nodes), ncol = nrow(edges))\r\nBmat_dir <- rep(\"==\", nrow(Bmat))\r\nBmat_rhs <- rep(0, nrow(Bmat))\r\n\r\nfor(i in 1:nrow(Bmat)){\r\n  node_id <- nodes[i, \"id\"]\r\n  for(j in 1:ncol(Bmat)){\r\n    edge_from <- edges[j,\"from\"]\r\n    edge_to <- edges[j, \"to\"]\r\n    edge_id <- edges[j, \"id\"]\r\n    \r\n    if(node_id == edge_from){\r\n      Bmat[i,j] = -1\r\n    }\r\n    else if(node_id == edge_to){\r\n      Bmat[i,j] = 1\r\n    }\r\n    else{\r\n      Bmat[i,j] = 0\r\n    }\r\n  }\r\n}\r\n\r\nBmat\r\n\r\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7]\r\n[1,]   -1   -1    0    0    0    0    1\r\n[2,]    1    0   -1   -1    0    0    0\r\n[3,]    0    1    1    0    0   -1    0\r\n[4,]    0    0    0    1   -1    0    0\r\n[5,]    0    0    0    0    1    1   -1\r\n\r\nBmat_dir\r\n\r\n[1] \"==\" \"==\" \"==\" \"==\" \"==\"\r\n\r\nBmat_rhs\r\n\r\n[1] 0 0 0 0 0\r\n\r\nObjective\r\nNext, the objective is going to be 0 for all values,\r\nexcept our final flow. This we want to maximize.\r\n\r\n\r\nf.obj <- c(rep(0, nrow(edges)-1), 1)\r\nf.obj\r\n\r\n[1] 0 0 0 0 0 0 1\r\n\r\nSolve the LP\r\nNow we unite everything together and drop it into the solver.\r\nRemember, we are trying to maximize flow. So specify\r\nmax.\r\n\r\n\r\nf.cons <- rbind(Amat, Bmat)\r\nf.rhs <- c(Amat_rhs, Bmat_rhs)\r\nf.dir <- c(Amat_dir, Bmat_dir)\r\n\r\nresults <- lp(direction = \"max\",  \r\n              objective.in = f.obj, \r\n              const.mat = f.cons, \r\n              const.dir = f.dir, \r\n              const.rhs = f.rhs)\r\nresults$solution\r\n\r\n[1] 1 2 0 1 1 2 3\r\n\r\nVisualize Maximum Flow\r\nSolution\r\nSince the results$solution contain the maximum flow we\r\ncan push through the pipes as a system, we can add this into our flow\r\ncomponent of the edges dataframe.\r\nThe visual indicates that 2/3 of the capacity was\r\nshipped to node 2, and 1/2 to\r\nnode 1. After this the next best transfer was from\r\nnode 2 to node 4 maxed out at\r\n2/2. This is indicated in red. The arcs that have flow are\r\nindicated in black, and no flow is indicated by grey. The maximum flow\r\narc is just an artificial arc that indicates the maximum\r\nflow, this is indicated in purple.\r\nLastly from the node 1 to node 3\r\n1/4 of the capacity was sent. Then from node 3\r\nto node 4 was maxed out at 1/1.\r\nPosterior analysis to this model output tells us that sending\r\n2 million tons of oil from the source to\r\ndestination 2 and 1 million tons of oil from\r\nthe source to destination 1 will push as much\r\nflow to destination 4 as we possibly can.\r\n\r\n\r\n# Set the flow\r\nedges$flow <- results$solution\r\n\r\n# If the arc is flowing oil, change to black\r\nedges$color[which(edges$flow > 0)] <- \"black\"\r\n\r\n# If the arc is at capacity change it to red\r\nedges$color[which(edges$flow == edges$capacity)] <- \"red\"\r\n\r\n# Last flow is purple\r\nedges$color[nrow(edges)] <- \"purple\"\r\n\r\n\r\ng <- igraph::graph_from_data_frame(d = edges,\r\n                                   directed = TRUE,\r\n                                   vertices = nodes)\r\n\r\n# Make it look a little more appealing\r\nL = cbind(1:5, 1:5)\r\nCURVE = c(0,0.15, 0.3, 0.45, 0, -0.15, -0.3, 0, 0.15, 0) * 5\r\n\r\n# Plot\r\nplot(g,\r\n     layout = L,\r\n     edge.curved = CURVE,\r\n     edge.label = paste(\"(\",E(g)$flow, \r\n                        \",\", \r\n                        E(g)$capacity, \")\", \r\n                        sep=\"\"), \r\n     main = \"Oil Pipeline Flow | (flow, capacity)\", \r\n     vertex.color = V(g)$color,\r\n     vertex.size = 25,\r\n     vertex.label.cex = 1.6,\r\n     edge.color = E(g)$color,\r\n     edge.width = E(g)$flow*2)\r\n\r\n\r\n\r\nCleaning Up The Visual\r\n\r\n\r\nvisNet_nodes <- nodes %>% \r\n                dplyr::mutate(label = paste(\"Location \", id),\r\n                              font.size =10,\r\n                              type = \"black\",\r\n                              shape = \"circle\",\r\n                              font = 12)\r\n\r\nvisNet_edges <- edges %>% \r\n                dplyr::mutate(label = paste(\"(\",flow,\",\",capacity,\")\",sep=\"\"),\r\n                              length = 250,\r\n                              width = flow*2,\r\n                              arrows = \"to\") \r\n  \r\nvisNetwork(visNet_nodes, \r\n           visNet_edges,\r\n           width = \"100%\",\r\n           main = \"Maximum Oil Flow | (flow, capacity)\")\r\n\r\n\r\n\r\nReferences\r\nExample taken from the following sources:\r\nWinston., Wayne. Operations Research, Applications and\r\nAlgorithms 4th Edition.\r\n\r\n\r\n\r\n",
    "preview": "posts/2022-07-09-maximum-network-flows-in-r/maximum-network-flows-in-r_files/figure-html5/initial_graph-1.png",
    "last_modified": "2022-07-10T09:03:29-04:00",
    "input_file": "maximum-network-flows-in-r.knit.md"
  }
]
